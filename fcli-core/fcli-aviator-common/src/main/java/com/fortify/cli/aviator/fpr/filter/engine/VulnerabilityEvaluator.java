/*
 * Copyright 2021-2025 Open Text.
 *
 * The only warranties for products and services of Open Text
 * and its affiliates and licensors ("Open Text") are as may
 * be set forth in the express warranty statements accompanying
 * such products and services. Nothing herein should be construed
 * as constituting an additional warranty. Open Text shall not be
 * liable for technical or editorial errors or omissions contained
 * herein. The information contained herein is subject to change
 * without notice.
 */
package com.fortify.cli.aviator.fpr.filter.engine;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fortify.cli.aviator.fpr.Vulnerability;
import com.fortify.cli.aviator.fpr.filter.SearchTree;

/**
 * Evaluates a parsed SearchTree against a Vulnerability object.
 */
public class VulnerabilityEvaluator {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityEvaluator.class);

    public static boolean evaluate(SearchTree tree, Vulnerability vuln) {
        if (tree == null || tree.getRoot() == null) {
            return true; // An empty filter matches everything
        }
        logger.trace("Evaluating vuln [{}] against filter tree.", vuln.getInstanceID());
        return evaluateNode(tree.getRoot(), vuln);
    }

    private static boolean evaluateNode(SearchTree.Node node, Vulnerability vuln) {
        if (node.isLeaf()) {
            Object attrValue = vuln.getAttributeValue(node.getQuery().getAttributeName());
            boolean result = node.getQuery().getSearchComparer().matches(attrValue);
            logger.trace("  LEAF EVAL: Query [attr {} = {} vs comparer {}] on vuln [{}] -> {}", node.getQuery().getAttributeName(), attrValue, node.getQuery().getSearchComparer(), vuln.getInstanceID(), result);
            return result;
        }

        boolean leftResult = evaluateNode(node.getLeftChild(), vuln);
        logger.trace("  LEFT RESULT: {}", leftResult);

        if (node.getOperator() == SearchTree.LogicalOperator.AND && !leftResult) {
            logger.trace("  OPERATOR EVAL (short-circuit): Left side of AND was false. Result: false");
            return false;
        }
        if (node.getOperator() == SearchTree.LogicalOperator.OR && leftResult) {
            logger.trace("  OPERATOR EVAL (short-circuit): Left side of OR was true. Result: true");
            return true;
        }

        boolean rightResult = evaluateNode(node.getRightChild(), vuln);
        logger.trace("  RIGHT RESULT: {}", rightResult);

        boolean finalResult = (node.getOperator() == SearchTree.LogicalOperator.AND)
                ? leftResult && rightResult
                : leftResult || rightResult;

        logger.trace("  OPERATOR EVAL: Left ({}) {} Right ({}) -> {}", leftResult, node.getOperator(), rightResult, finalResult);
        return finalResult;
    }
}