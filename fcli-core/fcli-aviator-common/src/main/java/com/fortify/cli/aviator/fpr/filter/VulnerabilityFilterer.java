package com.fortify.cli.aviator.fpr.filter;

import com.fortify.cli.aviator.fpr.Vulnerability;
import com.fortify.cli.aviator.fpr.filter.engine.FilterParser;
import com.fortify.cli.aviator.fpr.filter.engine.VulnerabilityEvaluator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class VulnerabilityFilterer {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityFilterer.class);
    private static final Pattern MODERN_SYNTAX_DETECTOR = Pattern.compile("\\b(AND|OR)\\b", Pattern.CASE_INSENSITIVE);

    public static List<Vulnerability> filter(List<Vulnerability> vulnerabilities, String queryString) {
        if (queryString == null || queryString.trim().isEmpty()) {
            return vulnerabilities;
        }
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            return vulnerabilities;
        }

        try {
            SearchTree searchTree;
            // Automatically detect which parser to use based on the presence of AND/OR
            if (MODERN_SYNTAX_DETECTOR.matcher(queryString).find()) {
                logger.trace("Modern syntax (AND/OR) detected for query: '{}'", queryString);
                searchTree = FilterParser.parse(queryString);
            } else {
                logger.trace("Legacy syntax detected for query: '{}'", queryString);
                searchTree = FilterParser.parseLegacy(queryString);
            }

            return vulnerabilities.stream()
                    .filter(vuln -> VulnerabilityEvaluator.evaluate(searchTree, vuln))
                    .collect(Collectors.toList());

        } catch (Exception e) {
            logger.error("Failed to parse or apply filter query '{}'. Returning no results for this filter.", queryString, e);
            // It's critical to log the stack trace here for debugging
            logger.error("Parsing exception:", e);
            return new ArrayList<>();
        }
    }

    public static List<Vulnerability> filterVulnerabilities(List<Vulnerability> vulnerabilities, FilterSet fs) {
        if (fs == null || fs.getFilters() == null || fs.getFilters().isEmpty() || vulnerabilities == null) {
            return vulnerabilities;
        }

        // Start with all
        List<Vulnerability> current = new ArrayList<>(vulnerabilities);
        boolean hasFolderFilters = false;
        Set<Vulnerability> inFolder = new HashSet<>();

        for (Filter f : fs.getFilters()) {
            String action = f.getAction().toLowerCase();
            String query = f.getQuery();
            SearchTree tree = MODERN_SYNTAX_DETECTOR.matcher(query).find() ? FilterParser.parse(query) : FilterParser.parseLegacy(query);

            List<Vulnerability> matching = current.stream()
                    .filter(v -> VulnerabilityEvaluator.evaluate(tree, v))
                    .collect(Collectors.toList());

            if ("setfolder".equals(action)) {
                hasFolderFilters = true;
                inFolder.addAll(matching); // Assign to folder (mark as inFolder)
            } else if ("hide".equals(action)) {
                current.removeAll(matching); // Hide (remove from current)
            }
        }

        // Final kept: from current (not hidden), and if folders present, only those inFolder
        if (hasFolderFilters) {
            current = current.stream().filter(inFolder::contains).collect(Collectors.toList());
        }

        logger.info("FilterSet '{}' applied. {} of {} vulnerabilities remain.", fs.getTitle(), current.size(), vulnerabilities.size());
        return current;
    }
}