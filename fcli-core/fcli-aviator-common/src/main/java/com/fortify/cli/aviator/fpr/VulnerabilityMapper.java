/*
 * Copyright 2021-2025 Open Text.
 *
 * The only warranties for products and services of Open Text
 * and its affiliates and licensors ("Open Text") are as may
 * be set forth in the express warranty statements accompanying
 * such products and services. Nothing herein should be construed
 * as constituting an additional warranty. Open Text shall not be
 * liable for technical or editorial errors or omissions contained
 * herein. The information contained herein is subject to change
 * without notice.
 */
package com.fortify.cli.aviator.fpr;

import java.util.Objects;
import java.util.Optional;

import com.fortify.cli.aviator.fpr.filter.AnalyzerType;

/**
 * A factory and mapper class responsible for safely converting a JAXB-generated
 * FVDL Vulnerability into our clean, internal application model.
 * <p>
 * This class encapsulates the logic for handling nulls and providing
 * sensible defaults, ensuring that the rest of the application works with
 * a reliable and predictable data structure. It uses the Builder pattern
 * on the Vulnerability class to enforce constraints.
 */
public final class VulnerabilityMapper {

    /**
     * Private constructor to prevent instantiation of this utility class.
     */
    private VulnerabilityMapper() {}

    /**
     * Maps a JAXB Vulnerability to the internal application's Vulnerability model.
     * This method is the single point of entry for converting raw FVDL data.
     *
     * @param jaxbVuln The raw vulnerability object from JAXB, which may contain nulls.
     * @return An Optional containing the clean Vulnerability object if the essential data is present.
     *         Returns an empty Optional if the JAXB object is null or missing critical identifiers.
     */
    public static Optional<Vulnerability> fromJAXB(com.fortify.cli.aviator.fpr.jaxb.Vulnerability jaxbVuln) {
        if (jaxbVuln == null || jaxbVuln.getClassInfo() == null || jaxbVuln.getInstanceInfo() == null) {
            return Optional.empty();
        }

        try {
            Vulnerability.VulnerabilityBuilder builder = Vulnerability.builder()
                    .classID(Objects.requireNonNull(jaxbVuln.getClassInfo().getClassID()))
                    .instanceID(Objects.requireNonNull(jaxbVuln.getInstanceInfo().getInstanceID()))
                    .analyzerName(AnalyzerType.canonicalizeAnalyzerName(jaxbVuln.getClassInfo().getAnalyzerName()))
                    .type(jaxbVuln.getClassInfo().getType())
                    .subType(jaxbVuln.getClassInfo().getSubtype())
                    .kingdom(jaxbVuln.getClassInfo().getKingdom())
                    .defaultSeverity(jaxbVuln.getClassInfo().getDefaultSeverity() != null ? jaxbVuln.getClassInfo().getDefaultSeverity() : 0.0)
                    .instanceSeverity(jaxbVuln.getInstanceInfo().getInstanceSeverity() != null ? jaxbVuln.getInstanceInfo().getInstanceSeverity() : 0.0)
                    .confidence(jaxbVuln.getInstanceInfo().getConfidence() != null ? jaxbVuln.getInstanceInfo().getConfidence() : 0.0)
                    .analysis(jaxbVuln.getInstanceInfo().getInstanceDescription());

            return Optional.of(builder.build());

        } catch (NullPointerException e) {
            // This happens if a *critical* field (classID or instanceID) was null.
            // We treat it as corrupt data.
            return Optional.empty();
        }
    }
}