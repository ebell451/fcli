package com.fortify.cli.aviator.fpr;


import com.fortify.cli.aviator.audit.model.File;
import com.fortify.cli.aviator.fpr.model.Entry;
import com.fortify.cli.aviator.fpr.utils.Searchable;
import com.fortify.cli.aviator.audit.model.StackTraceElement;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Represents a vulnerability with all extracted data from FVDL.
 * Implements Searchable for broad, non-specific text searches.
 * Uses a Builder pattern for safe and robust object creation.
 */
@Getter
@Setter
@ToString
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Vulnerability implements Searchable {
    private String analyzerName;
    private String classID;
    private double defaultSeverity;
    private String kingdom;
    private String type;
    private String subType;
    private double confidence;
    private String instanceID;
    private double instanceSeverity;
    private String analysis;

    private Double accuracy;
    private Double impact;
    private Double probability;
    private String filetype;
    private String likelihood;
    private String priority;
    private String projectName;
    private String category;
    private String subcategory;
    private String shortDescription;
    private String explanation;
    private String audience;
    private String buildId;
    private String uuid;

    @Builder.Default private List<List<StackTraceElement>> stackTrace = new ArrayList<>();
    @Builder.Default private List<File> files = new ArrayList<>();
    private List<StackTraceElement> firstStackTrace;
    private StackTraceElement lastStackTraceElement;
    private List<StackTraceElement> longestStackTrace;
    private StackTraceElement source;
    private StackTraceElement sink;
    @Builder.Default private List<String> taintFlags = new ArrayList<>();
    @Builder.Default private Map<String, String> knowledge = new HashMap<>();
    @Builder.Default private List<Map<String, String>> auxiliaryData = new ArrayList<>();
    @Builder.Default private List<Entry> externalEntries = new ArrayList<>();

    private String requestHeaders, requestParameters, requestBody, requestMethod, requestCookies, requestHttpVersion;
    private String attackPayload, attackType, response, trigger, vulnerableParameter;

    @Builder.Default private boolean isSuppressed = false;
    @Builder.Default private boolean isAudited = false;
    @Builder.Default private String issueStatus = "New";
    private String lastComment;

    private static final Logger filterLogger = LoggerFactory.getLogger(Vulnerability.class.getName() + ".Filter");

    // --- Searchable Implementation ---

    @Override
    public boolean contains(String searchString) {
        if (searchString == null || searchString.isEmpty()) return false;
        String lowerSearch = searchString.toLowerCase();

        return anyStringContains(lowerSearch, analyzerName, classID, kingdom, type, subType, instanceID,
                filetype, likelihood, priority, projectName, analysis, category, subcategory,
                shortDescription, explanation, audience, requestMethod, attackType, vulnerableParameter) ||
                taintFlags.stream().anyMatch(f -> f.toLowerCase().contains(lowerSearch)) ||
                knowledge.values().stream().anyMatch(v -> v != null && v.toLowerCase().contains(lowerSearch)) ||
                files.stream().anyMatch(f -> f.getName().toLowerCase().contains(lowerSearch) || (f.getContent() != null && f.getContent().toLowerCase().contains(lowerSearch)));
    }

    @Override
    public boolean matches(String matchString) {
        if (matchString == null || matchString.isEmpty()) return false;

        return anyStringEquals(matchString, analyzerName, classID, kingdom, type, subType, instanceID,
                filetype, likelihood, priority, projectName, analysis, category, subcategory,
                shortDescription, explanation, audience, requestMethod, attackType, vulnerableParameter) ||
                taintFlags.stream().anyMatch(f -> f.equalsIgnoreCase(matchString)) ||
                knowledge.values().stream().anyMatch(v -> v != null && v.equalsIgnoreCase(matchString)) ||
                files.stream().anyMatch(f -> f.getName().equalsIgnoreCase(matchString));
    }

    @Override
    public boolean matchesPattern(Pattern pattern) {
        if (pattern == null) return false;

        return anyStringMatchesPattern(pattern, analyzerName, classID, kingdom, type, subType, instanceID,
                filetype, likelihood, priority, projectName, analysis, category, subcategory,
                shortDescription, explanation, audience, requestMethod, attackType, vulnerableParameter) ||
                taintFlags.stream().anyMatch(f -> pattern.matcher(f).matches()) ||
                knowledge.values().stream().anyMatch(v -> v != null && pattern.matcher(v).matches()) ||
                files.stream().anyMatch(f -> pattern.matcher(f.getName()).matches());
    }

    // --- Searchable Helpers ---
    private boolean anyStringContains(String lowerSearch, String... fields) {
        for (String field : fields) {
            if (field != null && field.toLowerCase().contains(lowerSearch)) return true;
        }
        return false;
    }
    private boolean anyStringEquals(String matchString, String... fields) {
        for (String field : fields) {
            if (field != null && field.equalsIgnoreCase(matchString)) return true;
        }
        return false;
    }
    private boolean anyStringMatchesPattern(Pattern pattern, String... fields) {
        for (String field : fields) {
            if (field != null && pattern.matcher(field).matches()) return true;
        }
        return false;
    }

    /**
     * Dynamically retrieves an attribute's value by its string name for filtering.
     * This is the bridge between the filter query and the object's rich data.
     *
     * The logic prioritizes direct, instance-specific, or derived fields first.
     * If an attribute is not found directly, it falls back to searching the
     * 'knowledge' map, which contains all metadata inherited from the FVDL Rule.
     *
     * @param attributeName The case-insensitive name of the attribute to retrieve.
     * @return The value of the attribute, or null if not found or a parsing error occurs.
     */
    public Object getAttributeValue(String attributeName) {
        if (attributeName == null) {
            return null;
        }

        Object valueToReturn = null;
        String lowerAttributeName = attributeName.toLowerCase();

        try {
            // --- Strategy 1: Check direct, derived, or instance-specific fields first ---
            switch (lowerAttributeName) {
                // --- Direct Numeric Fields ---
                case "impact": valueToReturn = this.getImpact(); break;
                case "likelihood": valueToReturn = (this.getLikelihood() != null && !this.getLikelihood().isEmpty()) ? Double.parseDouble(this.getLikelihood()) : null; break;
                case "confidence": valueToReturn = this.getConfidence(); break;
                case "instanceseverity": valueToReturn = this.getInstanceSeverity(); break;
                case "linenumber": valueToReturn = (double) (this.getSource() != null ? this.getSource().getLine() : 0); break;
                case "sourceline": valueToReturn = (this.getSource() != null) ? (double) this.getSource().getLine() : 0.0; break;

                // --- Direct String Fields ---
                case "priority": valueToReturn = this.getPriority(); break;
                case "category": valueToReturn = this.getCategory(); break;
                case "analyzer": valueToReturn = this.getAnalyzerName(); break;
                case "instanceid": valueToReturn = this.getInstanceID(); break;
                case "package": valueToReturn = this.getProjectName(); break;
                case "filetype": valueToReturn = this.getFiletype(); break;
                case "issuestatus": valueToReturn = this.getIssueStatus(); break;
                case "audience": valueToReturn = this.getAudience(); break;

                // --- Complex / Aggregated Fields ---
                case "filename": valueToReturn = this.getFiles().stream().map(File::getName).collect(Collectors.joining(" ")); break;
                case "taintflags": valueToReturn = String.join(" ", this.getTaintFlags()); break;
                case "tracenode": valueToReturn = getFullTraceAsText(this.getStackTrace()); break;
                case "sourcefile": valueToReturn = (this.getSource() != null) ? this.getSource().getFilename() : ""; break;
                case "shortfilename": valueToReturn = (this.getSource() != null && this.getSource().getFilename() != null) ? new java.io.File(this.getSource().getFilename()).getName() : ""; break;

                // --- Boolean Fields ---
                case "suppressed": valueToReturn = this.isSuppressed(); break;
                case "audited": valueToReturn = this.isAudited(); break;
            }

            // --- Strategy 2: If not found above, fall back to the knowledge map ---
            // This covers all rule-based metadata like 'Accuracy', 'Probability', 'Kingdom', 'CWE', etc.
            if (valueToReturn == null) {
                for (Map.Entry<String, String> entry : this.getKnowledge().entrySet()) {
                    if (entry.getKey() != null &&  entry.getKey().equalsIgnoreCase(lowerAttributeName)) {
                        String stringValue = entry.getValue();
                        // Attempt to convert to a number if it looks like one, for numeric comparisons.
                        if (stringValue != null && stringValue.matches("^-?[0-9.]+$")) {
                            try {
                                valueToReturn = Double.parseDouble(stringValue);
                            } catch (NumberFormatException e) {
                                valueToReturn = stringValue; // It wasn't a valid double, treat as string
                            }
                        } else {
                            valueToReturn = stringValue;
                        }
                        break;
                    }
                }
            }

        } catch (Exception e) {
            filterLogger.warn("Error retrieving value for attribute '{}' on issue {}. Error: {}", attributeName, this.getInstanceID(), e.getMessage());
            return null;
        }

        if (valueToReturn == null) {
            filterLogger.trace("Attribute '{}' not found for vuln [{}].", lowerAttributeName, this.getInstanceID());
        } else {
            filterLogger.trace("  - For vuln [{}], attribute '{}' -> returned value [{}]", this.getInstanceID(), lowerAttributeName, valueToReturn);
        }

        return valueToReturn;
    }
    private String getFullTraceAsText(List<List<StackTraceElement>> traces) {
        if (traces == null || traces.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (List<StackTraceElement> trace : traces) {
            for (StackTraceElement element : trace) {
                appendElementText(element, sb);
            }
        }
        return sb.toString();
    }

    private void appendElementText(StackTraceElement element, StringBuilder sb) {
        if (element == null) return;
        sb.append(element.getFilename()).append(" ");
        sb.append(element.getCode()).append(" ");
        sb.append(element.getNodeType()).append(" ");
        sb.append(element.getAdditionalInfo()).append(" ");
        for (StackTraceElement inner : element.getInnerStackTrace()) {
            appendElementText(inner, sb);
        }
    }
}